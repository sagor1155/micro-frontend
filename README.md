# Micro-Frontend (MFE)
Micro-frontend Demo Project in Angular

## Topic List
- > Load remote module/component using "webpack module federation"
- > Load remote component from HTML (Plugin based approach)
- > Input/Output binding with remote component using "ngx-mfe"
- > Communication between MFE using CustomEvent
- > Communication between MFE using Shared Service and RxJs
- MFE using web components (@angular/elements)
- Load remote MFE from another MFE
- Sharing code and resources
  - > library/services
  - style
  - config
  - version mismatch issue
- Passing Injector to MFE, Why & when do we need this? 
- Router snapshot/navigate behaviour within Shell (Host) & MFE
- Route reuse strategy in MFEs
- Config based remote module loading from Shell
- Necessary libraries
  - > Webpack module federation
  - > ngx-mfe
  - angular/elements
  - nx
  - systemjs
  - single-spa
- Mono repo vs Separate repo
- Deploy MFEs


# Load remote module/component using "webpack module federation"
### Ref: 
- https://github.com/angular-architects/module-federation-plugin/blob/main/libs/mf/tutorial/tutorial.md 
- https://www.npmjs.com/package/@angular-architects/module-federation

## Project setup
- ### Create workspace
    `ng n micro-frontend-demo --create-application false`

- ### Go to workspace directory
    `cd micro-frontend-demo`

- ### Create shell (host) application
    `ng generate application shell --routing`

- ### Add component into shell (host) application
    `ng g c landingpage --project=shell`

- ### Create MFE application
    `ng generate application products --routing`

- ### Add module into MFE application
    `ng g module dashboard --routing --project=products`

    `ng g module catalog --routing --project=products`

- ### Add component into MFE application
    `ng g c dashboard/dashboard --project=products`

    `ng g c catalog/catalog --project=products`

- ### Install and activate module federation library into the Shell
    `ng add @angular-architects/module-federation --project shell --type host --port 4200`

- ### Install and activate module federation library into the MFE
    `ng add @angular-architects/module-federation --project products --type remote --port 3000`

## Configure module federation in remote MFE
- Go to project **products**, open `webpack.config.js` and configure like following
  
  ```js
  const { 
    withModuleFederationPlugin,
    share 
  } = require('@angular-architects/module-federation/webpack');

  module.exports = withModuleFederationPlugin({
    name: 'products',
    filename: 'products.js',
    exposes: {
        DashboardModule: './projects/products/src/app/dashboard/dashboard.module.ts',
        DashboardComponent: './projects/products/src/app/dashboard/dashboard/dashboard.component.ts',
        CatalogModule: './projects/products/src/app/catalog/catalog.module.ts',
        CatalogComponent: './projects/products/src/app/catalog/catalog/catalog.component.ts'
    },
    shared: share({
        '@angular/animations': {singleton: true, strictVersion: true},
        '@angular/core': {singleton: true, strictVersion: true},
        '@angular/common': {singleton: true, strictVersion: true},
        '@angular/forms': {singleton: true, strictVersion: true},
        '@angular/platform-browser': {singleton: true, strictVersion: true},
        '@angular/router': {singleton: true, strictVersion: true},
        'rxjs': {singleton: true, strictVersion: true, requiredVersion: false}
    })
  });
  ```

  Here,
  - `name` is the scope name which should be unique for a specific MFE.
  - `filename` is the file generated by webpack.
  - On `exposes` section add the module/component name and path which we want to expose. These modules/components will be available to be loaded remotely from Host or, another MFE. 
  - Libraries added on `shared` section will be shared among Host and MFEs. So, the MFEs bundle will not include these libraries, thus it will reduce the bundle size. 

- Import `DashboardModule` from `app.module.ts`
  ```ts
  @NgModule({
    ...
    imports: [
      BrowserModule,
      AppRoutingModule,
      DashboardModule
    ]
    ...
  })
  ```
- Configure route in `dashboard-routing.module.ts`
  ```ts
  const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent
  }
  ];
  ```

  
## Configure module federation in Host
- Go to project 'shell', open `webpack.config.js` and configure like following
  
  ```js
  const { 
    withModuleFederationPlugin,
    share 
  } = require('@angular-architects/module-federation/webpack');

  module.exports = withModuleFederationPlugin({
    /*
    remotes: {
      products: 'http://localhost:3000/products.js',
    },
    */
    shared: share({
        '@angular/animations': {singleton: true, strictVersion: true},
        '@angular/core': {singleton: true, strictVersion: true},
        '@angular/common': {singleton: true, strictVersion: true},
        '@angular/forms': {singleton: true, strictVersion: true},
        '@angular/platform-browser': {singleton: true, strictVersion: true},
        '@angular/router': {singleton: true, strictVersion: true},
        'rxjs': {singleton: true, strictVersion: true, requiredVersion: false}
    })
  });
  ```

  Here, 
  - Remote module location can be configured in `remotes` section. This references the separately compiled and deployed MFE (`products`) project. But there is an alternative way which is shown in below section.

## Load remote modules/components dynamically from Shell
- Open the `Shell`'s router config (`app-routing.module.ts`) and add route for loading MFEs
  
  ```ts
  const routes: Routes = [
  ...
  {
    path: 'dashboard',
    loadChildren: () => loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:3000/products.js',
      exposedModule: 'DashboardModule'
    }).then(m => m.DashboardModule)
  },
  {
    path: 'catalog',
    loadChildren: () => loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:3000/products.js',
      exposedModule: 'CatalogModule'
    }).then(m => m.CatalogModule)
  }
  ...
  ];
  ```

## Run the projects
- Run MFE  
  `ng serve products`

- Run Host  
  `ng serve shell`

- Open the URL `http://localhost:4200/dashboard/dashboard` in browser. This should load the remote MFE into the shell. 


# Load remote component from HTML (Plugin based approach)
This approach allows us to load micro-frontends directly from HTML.
The main advantage of this approach is that, we can display several MFEs at once on the same page.

## Loading remote component from HTML using "ViewContainerRef"
In Shell application - 

`landingpage.component.html`
```html
<div #placeHolder></div>
```
`landingpage.component.ts`
```ts
@ViewChild('placeHolder', { read: ViewContainerRef }) viewContainerRef!: ViewContainerRef;
```

```ts
ngOnInit() {
  this.loadCatalogComponent();
}
```

```ts
async loadCatalogComponent(): Promise<void> {
  const m = await loadRemoteModule(<LoadRemoteModuleEsmOptions>{
    type: 'module',
    remoteEntry: 'http://localhost:3000/products.js',
    exposedModule: 'CatalogModule'
  });
  const ref = this.viewContainerRef.createComponent(m.CatalogComponent);
}
```

## Loading remote component from HTML using "ngx-mfe"
The main advantage of using `ngx-mfe` library is that, we can bind input/output with MFE's. It also has support for features like loader, loader delay, fallback etc.  
### Ref:
- https://github.com/dkhrunov/ngx-mfe
- https://dekh.medium.com/angular-micro-frontend-architecture-part-3-3-mfe-plugin-based-approach-f36dc9849b0#339a

### Install 'ngx-mfe' library
`npm i ngx-mfe`

### Configure library
Add the `ngx-mfe` library to `shared` property in the `ModuleFederationPlugin` inside `webpack.config.js` file for each application in your workspace.

```js
module.exports = withModuleFederationPlugin({
  shared: share({
    ...
    "ngx-mfe": { singleton: true, strictVersion: true, requiredVersion: 'auto'}
  })
});
```

In Shell `app.module.ts`, import `MfeModule` with options - 
```ts
imports: [
  ...
  MfeModule.forRoot({
    mfeConfig: {
      "products": "http://localhost:3000/products.js",
    },
    loaderDelay: 500
  })
],
```

In MFE `app.module.ts`, import `MfeModule` without options - 
```ts
imports: [
  ...
  MfeModule
],
```

### Conventions
- To display a standalone MFE component, you only need the component file itself. 
- To display an MFE component with dependencies in the module where the component was declared, you must expose both the component file and the module file from **ModuleFederationPlugin**.
- The file key of an exposed Module or Component (declared in the **ModuleFederationPlugin** in the **expose** property) must match the class name of that file.
- You must follow the rule that only one Component must be declared for an exposed Module. This is known as SCAM (Single Component Angular Module) pattern.

### Load component
In Shell app `landingpage.component.html` file add this: 
```html
<ng-container
  mfeOutlet="products"
  mfeOutletModule="CatalogModule"
  mfeOutletComponent="CatalogComponent"
  [mfeOutletInputs]="{ text: inputText }"
  [mfeOutletOutputs]="{ click: onClick }"
  [mfeOutletLoaderDelay]="500"
  [mfeOutletLoader]="loaderTpl"
  [mfeOutletFallback]="fallbackTpl"
>
</ng-container>

<ng-template #loaderTpl>
  <div>loading...</div>
</ng-template>

<ng-template #fallbackTpl>
  <div>Ooops! Something went wrong</div>
</ng-template>
```

Here:
- `mfeOutlet` - scope name
- `mfeOutletModule` - module name (MUST specify if not standalone component)
- `mfeOutletComponent` - component name
- `mfeOutletInputs` - property binding
- `mfeOutletOutputs` - event binding
- `mfeOutletLoaderDelay` - waits before loading MFE
- `mfeOutletLoader` - loader template is shown before loading MFE
- `mfeOutletFallback` - fallback template is shown if MFE loading failed

