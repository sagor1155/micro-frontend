# Micro-Frontend (MFE)
Micro-frontend Demo Project in Angular

## Topic List
- [&check;] Load remote module/component using "webpack module federation"
- [&check;] Load remote component from HTML (Plugin based approach)
    - [&check;] Loading remote component from HTML using "ViewContainerRef"
    - [&check;] Loading remote component from HTML using "ngx-mfe"
- [&check;] Communication between MFEs using CustomEvent
- [&check;] Communication between MFEs using Shared Service and RxJs
- [&cross;] MFE using web components (@angular/elements)
- [&cross;] Load remote MFE from another MFE
- [&cross;] Sharing code and resources
  - [&check;] library/services
  - [&cross;] style
  - [&cross;] config
  - [&cross;] version mismatch issue
- [&cross;] Passing Injector to MFE, Why & when do we need this? 
- [&cross;] Router snapshot/navigate behaviour within Shell (Host) & MFE
- [&cross;] Route reuse strategy in MFEs
- [&cross;] Config based remote module loading from Shell
- [&cross;] Necessary libraries
  - [&check;] [module-federation](https://www.npmjs.com/package/@angular-architects/module-federation)
  - [&cross;] [module-federation-tools](https://www.npmjs.com/package/@angular-architects/module-federation-tools)
  - [&check;] [ngx-mfe](https://socket.dev/npm/package/ngx-mfe)
  - [&cross;] [angular/elements](https://www.npmjs.com/package/@angular/elements)
  - [&cross;] [nx](https://nx.dev/recipes/module-federation/dynamic-module-federation-with-angular)
  - [&cross;] [systemjs](https://github.com/systemjs/systemjs)
  - [&cross;] [single-spa](https://single-spa.js.org/docs/microfrontends-concept/)
- [&cross;] Mono repo vs Separate repo
- [&cross;] Analyze bundle size
- [&cross;] Deploy MFEs


# Load remote module/component using "webpack module federation"
### Ref: 
- https://github.com/angular-architects/module-federation-plugin/blob/main/libs/mf/tutorial/tutorial.md 
- https://www.npmjs.com/package/@angular-architects/module-federation

## Project setup
- ### Create workspace
    `ng n micro-frontend-demo --create-application false`

- ### Go to workspace directory
    `cd micro-frontend-demo`

- ### Create shell (host) application
    `ng generate application shell --routing`

- ### Add component into shell (host) application
    `ng g c landingpage --project=shell`

- ### Create MFE application
    `ng generate application products --routing`

- ### Add module into MFE application
    `ng g module dashboard --routing --project=products`

    `ng g module catalog --routing --project=products`

- ### Add component into MFE application
    `ng g c dashboard/dashboard --project=products`

    `ng g c catalog/catalog --project=products`

- ### Install and activate module federation library into the Shell
    `ng add @angular-architects/module-federation --project shell --type host --port 4200`

- ### Install and activate module federation library into the MFE
    `ng add @angular-architects/module-federation --project products --type remote --port 3000`

## Configure module federation in remote MFE
- Go to project **products**, open `webpack.config.js` and configure like following
  
  ```js
  const { 
    withModuleFederationPlugin,
    share 
  } = require('@angular-architects/module-federation/webpack');

  module.exports = withModuleFederationPlugin({
    name: 'products',
    filename: 'products.js',
    exposes: {
        DashboardModule: './projects/products/src/app/dashboard/dashboard.module.ts',
        DashboardComponent: './projects/products/src/app/dashboard/dashboard/dashboard.component.ts',
        CatalogModule: './projects/products/src/app/catalog/catalog.module.ts',
        CatalogComponent: './projects/products/src/app/catalog/catalog/catalog.component.ts'
    },
    shared: share({
        '@angular/animations': {singleton: true, strictVersion: true},
        '@angular/core': {singleton: true, strictVersion: true},
        '@angular/common': {singleton: true, strictVersion: true},
        '@angular/forms': {singleton: true, strictVersion: true},
        '@angular/platform-browser': {singleton: true, strictVersion: true},
        '@angular/router': {singleton: true, strictVersion: true},
        'rxjs': {singleton: true, strictVersion: true, requiredVersion: false}
    })
  });
  ```

  Here,
  - `name` is the scope name which should be unique for a specific MFE.
  - `filename` is the file generated by webpack.
  - On `exposes` section add the module/component name and path which we want to expose. These modules/components will be available to be loaded remotely from Host or, another MFE. 
  - Libraries added on `shared` section will be shared among Host and MFEs. So, the MFEs bundle will not include these libraries, thus it will reduce the bundle size. 

- Import `DashboardModule` from `app.module.ts`
  ```ts
  @NgModule({
    ...
    imports: [
      BrowserModule,
      AppRoutingModule,
      DashboardModule
    ]
    ...
  })
  ```
- Configure route in `dashboard-routing.module.ts`
  ```ts
  const routes: Routes = [
  {
    path: 'dashboard',
    component: DashboardComponent
  }
  ];
  ```

  
## Configure module federation in Host
- Go to project 'shell', open `webpack.config.js` and configure like following
  
  ```js
  const { 
    withModuleFederationPlugin,
    share 
  } = require('@angular-architects/module-federation/webpack');

  module.exports = withModuleFederationPlugin({
    /*
    remotes: {
      products: 'http://localhost:3000/products.js',
    },
    */
    shared: share({
        '@angular/animations': {singleton: true, strictVersion: true},
        '@angular/core': {singleton: true, strictVersion: true},
        '@angular/common': {singleton: true, strictVersion: true},
        '@angular/forms': {singleton: true, strictVersion: true},
        '@angular/platform-browser': {singleton: true, strictVersion: true},
        '@angular/router': {singleton: true, strictVersion: true},
        'rxjs': {singleton: true, strictVersion: true, requiredVersion: false}
    })
  });
  ```

  Here, 
  - Remote module location can be configured in `remotes` section. This references the separately compiled and deployed MFE (`products`) project. But there is an alternative way which is shown in below section.

## Load remote modules/components dynamically from Shell
- Open the `Shell`'s router config (`app-routing.module.ts`) and add route for loading MFEs
  
  ```ts
  const routes: Routes = [
  ...
  {
    path: 'dashboard',
    loadChildren: () => loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:3000/products.js',
      exposedModule: 'DashboardModule'
    }).then(m => m.DashboardModule)
  },
  {
    path: 'catalog',
    loadChildren: () => loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:3000/products.js',
      exposedModule: 'CatalogModule'
    }).then(m => m.CatalogModule)
  }
  ...
  ];
  ```

## Run the projects
- Run MFE  
  `ng serve products`

- Run Host  
  `ng serve shell`

- Open the URL `http://localhost:4200/dashboard/dashboard` in browser. This should load the remote MFE into the shell. 


# Load remote component from HTML (Plugin based approach)
This approach allows us to load micro-frontends directly from HTML.
The main advantage of this approach is that, we can display several MFEs at once on the same page.

## Loading remote component from HTML using "ViewContainerRef"
In Shell application - 

`landingpage.component.html`
```html
<div #placeHolder></div>
```
`landingpage.component.ts`
```ts
@ViewChild('placeHolder', { read: ViewContainerRef }) viewContainerRef!: ViewContainerRef;
```

```ts
ngOnInit() {
  this.loadCatalogComponent();
}
```

```ts
async loadCatalogComponent(): Promise<void> {
  const m = await loadRemoteModule(<LoadRemoteModuleEsmOptions>{
    type: 'module',
    remoteEntry: 'http://localhost:3000/products.js',
    exposedModule: 'CatalogModule'
  });
  const ref = this.viewContainerRef.createComponent(m.CatalogComponent);
}
```

> Binding Input/Output this way is difficult which can be achieved simply by using **ngx-mfe** library

## Loading remote component from HTML using "ngx-mfe"
The main advantage of using `ngx-mfe` library is that, we can bind input/output with MFE's. It also has support for features like loader, loader delay, fallback, mfe registry etc.  
### Ref:
- https://github.com/dkhrunov/ngx-mfe
- https://dekh.medium.com/angular-micro-frontend-architecture-part-3-3-mfe-plugin-based-approach-f36dc9849b0#339a

### Install 'ngx-mfe' library
`npm i ngx-mfe`

### Configure library
Add the `ngx-mfe` library to `shared` property in the `ModuleFederationPlugin` inside `webpack.config.js` file for each application in your workspace.

```js
module.exports = withModuleFederationPlugin({
  shared: share({
    ...
    "ngx-mfe": { singleton: true, strictVersion: true, requiredVersion: 'auto'}
  })
});
```

In Shell `app.module.ts`, import `MfeModule` with options - 
```ts
imports: [
  ...
  MfeModule.forRoot({
    mfeConfig: {
      "products": "http://localhost:3000/products.js",
    },
    loaderDelay: 500
  })
],
```

In MFE `app.module.ts`, import `MfeModule` without options - 
```ts
imports: [
  ...
  MfeModule
],
```

### Conventions
- To display a standalone MFE component, you only need the component file itself. 
- To display an MFE component with dependencies in the module where the component was declared, you must expose both the component file and the module file from **ModuleFederationPlugin**.
- The file key of an exposed Module or Component (declared in the **ModuleFederationPlugin** in the **expose** property) must match the class name of that file.
- You must follow the rule that only one Component must be declared for an exposed Module. This is known as SCAM (Single Component Angular Module) pattern.

### Load component and Input/Output binding
In Shell app `landingpage.component.html` file add this: 
```html
<ng-container
  mfeOutlet="products"
  mfeOutletModule="CatalogModule"
  mfeOutletComponent="CatalogComponent"
  [mfeOutletInputs]="{ text: inputText }"
  [mfeOutletOutputs]="{ click: onClick }"
  [mfeOutletLoaderDelay]="500"
  [mfeOutletLoader]="loaderTpl"
  [mfeOutletFallback]="fallbackTpl"
>
</ng-container>

<ng-template #loaderTpl>
  <div>loading...</div>
</ng-template>

<ng-template #fallbackTpl>
  <div>Ooops! Something went wrong</div>
</ng-template>
```

Here:
- `mfeOutlet` - scope name
- `mfeOutletModule` - module name (MUST specify if not standalone component)
- `mfeOutletComponent` - component name
- `mfeOutletInputs` - property binding
- `mfeOutletOutputs` - event binding
- `mfeOutletLoaderDelay` - waits before loading MFE
- `mfeOutletLoader` - loader template is shown before loading MFE
- `mfeOutletFallback` - fallback template is shown if MFE loading failed


> Note: **ngx-mfe** library has a problem that is the output event handler/callback can't access component members/property. 

Following code will throw an error on console - 
```ts
onClick() {
  this.hostComponentMemberFunction();
  console.log('Click from MFE');
}
```

Error:
```bash
ERROR TypeError: Cannot read properties of undefined (reading 'hostComponentMemberFunction')
```

# Communication between MFEs using CustomEvent
Create and dispatch **CustomEvent** from MFE (`dashboard.component.ts`)
```ts
const customEvent = new CustomEvent('eventFromMfe', {detail: {name: 'IBFD'}})
window.dispatchEvent(customEvent);
```

Subscribe to **CustomEvent** from Shell (`landingpage.component.ts`)
```ts
this.subscription.add(fromEvent<CustomEvent>(window, 'eventFromMfe').subscribe(console.log));
```

# Communication between MFEs using Shared Service and RxJs

- Add a library in monorepo
  
  `ng g lib utils`
  
  It will be created within **projects** directory. 

- It will generate `projects/utils/src/public-api.ts` which looks like following - 
    ```ts
    export * from './lib/utils.service';
    export * from './lib/utils.component';
    export * from './lib/utils.module';
    ``` 

- Configure shared library in `webpack.config.js` for both Shell & MFE
  ```js
  module.exports = withModuleFederationPlugin({
    ...
    shared: share({
    ...
    "projects/utils/src/public-api": { singleton: true, strictVersion: true, requiredVersion: 'auto'}
    })
  });
  ```

- In Shell app, import `UtilsModule` from `app.module.ts`
  ```ts
  imports: [
    ...
    UtilsModule
  ],
  ```
- In MFE app, import `UtilsModule` from `app.module.ts`
  ```ts
  imports: [
    ...
    UtilsModule
  ],
  ```
- Use shared singleton service in MFE
  ```ts
  import { UtilsService } from 'projects/utils/src/public-api';
  ```  
  ```ts
    constructor(private utilsService: UtilsService) {}
  ```
  ```ts
    this.utilsService.publistTestEvent(true);
  ```
- Use shared singleton service in Shell
  ```ts
  import { UtilsService } from 'projects/utils/src/public-api';
  ```
  ```ts
  constructor(private utilsService: UtilsService) {}
  ```
  ```ts
  this.subscription.add(this.utilsService.getTestEvent().subscribe(data => {
    console.log('Shell: Received Event Notification from MFE');
  }));
  ```
### Ref:
- https://github.com/angular-architects/module-federation-plugin/blob/main/libs/mf/tutorial/tutorial.md#step-5-communication-between-micro-frontends-and-sharing-monorepo-libraries


# MFE using web components (@angular/elements)
Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way.

- Install **@angular/elements**  

  `npm i @angular/elements`

- Install @angular-architects/module-federation-tools

  `npm i @angular-architects/module-federation-tools`

- 

### Ref:
- https://angular.io/guide/elements
- https://www.youtube.com/watch?v=A0JAZhyYXGA&t=238s
- https://www.npmjs.com/package/@angular-architects/module-federation-tools
- https://github.com/angular-architects/module-federation-plugin/blob/main/libs/mf-tools/tutorial/index.md
- https://www.angulararchitects.io/aktuelles/multi-framework-and-version-micro-frontends-with-module-federation-the-good-the-bad-the-ugly/